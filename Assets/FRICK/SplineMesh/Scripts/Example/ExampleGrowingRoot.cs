using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to show the deformation of the mesh on a changing
    /// interval and changing spline nodes.
    /// 
    /// In this example, as the MeshBender is working on spline space, it will update
    /// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
    /// it will compute the mesh only once on it's next update call.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// </summary>
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class ExampleGrowingRoot : MonoBehaviour {
        private GameObject generated;
        private Spline spline;
        private float rate = 0;
        private MeshBender meshBender;

        [SerializeField] GameStart gameStart;
        [SerializeField] GameEnd gameEnd;
        [SerializeField] float speed = 2;

        public Mesh mesh;
        public Material material;
        public Vector3 rotation;
        public Vector3 scale;

        public float startScale = 1;

        public float DurationInSecond;

        private void OnEnable() {
            rate = 0;
            Init();
        }

        private void OnValidate() {
            Init();
        }

        private void Update() {
            if(gameStart.flag_start&&!gameEnd.flag_gameEnd)
            {
                EditorUpdate();
            }
        }

        void EditorUpdate() {
            rate += Time.deltaTime / DurationInSecond;
            if (rate > 1) {
                rate --;
                Vector3 mousePosition = Input.mousePosition;
                mousePosition.z = 10;
                Vector3 target = Camera.main.ScreenToWorldPoint(mousePosition);
                float y = -target.y;

                if(y < spline.nodes[spline.curves.Count].Position.y)
                {
                    y = spline.nodes[spline.curves.Count].Position.y + 0.5f;   
                }

                spline.AddNode(new SplineNode(
                    new Vector3(target.x, y, 0),
                    new Vector3(
                            target.x + (spline.nodes[spline.curves.Count].Position.x - spline.nodes[spline.curves.Count - 1].Position.x),
                            y + (spline.nodes[spline.curves.Count].Position.y - spline.nodes[spline.curves.Count - 1].Position.y),
                            0))
                );
            }
            
            if(Camera.main.transform.position.y > (-spline.nodes[spline.curves.Count].Position.y))
            {
                Camera.main.transform.position += new Vector3(0, -speed , 0) * Time.deltaTime;
            }

            Contort();
        }

        private void Contort() {
            float nodeDistance = 0;
            int i = 0;
            foreach (var n in spline.nodes) {
                float nodeScale1 = startScale * rate;
                float nodeScale2 = startScale - (startScale * rate);
                spline.nodes[spline.curves.Count - 1].Scale = new Vector2(nodeScale1, nodeScale1);
                spline.nodes[spline.curves.Count].Scale = new Vector2(nodeScale2, nodeScale2);
                if (i < spline.curves.Count) {
                    nodeDistance += spline.curves[i++].Length;
                }
            }

            if (generated != null) {
                float LastLength = spline.curves[spline.curves.Count - 1].Length;
                meshBender.SetInterval(spline, 0, (spline.Length - LastLength) + (LastLength * rate));
                meshBender.ComputeIfNeeded();
            }
        }

        private void Init() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));

            generated.GetComponent<MeshRenderer>().material = material;

            meshBender = generated.GetComponent<MeshBender>();
            spline = GetComponent<Spline>();

            meshBender.Source = SourceMesh.Build(mesh)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
            meshBender.SetInterval(spline, 0, 0.01f);
        }
    }
}
